import os
import itertools
import time 

import matplotlib.pyplot as plt
from numpy.random import random
import pandas as pd
import numpy as np

import shapely.affinity
from shapely.geometry import Point, Polygon

'''
Auxiliary module for clustering damage models data. 

Author: Ian Viotti, 2022
'''


def plot_damage(dam_var, plate_x = 0.2, plate_y = 0.2, **kwargs):
    '''Plots ellipse damage in plate for given damage variables and position limits if **kwargs == True'''
    
    min_bounds = kwargs.get('min_bounds')
    max_bounds = kwargs.get('max_bounds')
    
    pos_x = dam_var[0]
    pos_y = dam_var[1]
    theta = dam_var[2]
    c = dam_var[3]
    r = dam_var[4]
    
    # Rectangle definition
    polygon1 = Polygon([(0, 0),
       (plate_x, 0),
       (plate_x, plate_y),
       (0, plate_y),
    ])
    
    if min_bounds and max_bounds:
        polygon2 = Polygon([(min_bounds, min_bounds),
           (min_bounds, max_bounds),
           (max_bounds, max_bounds),
           (max_bounds, min_bounds),
        ])

    # Ellipse definition
    r_circ = 1
    circle = Point(pos_x, pos_y).buffer(r_circ)  # type(circle)=polygon
    ellipse1 = shapely.affinity.scale(circle, c/2, r*c/2)  # type(ellipse)=polygon
    ellipse = shapely.affinity.rotate(ellipse1, theta)

    # Plot
    plt.rcParams["figure.figsize"] = [6.00, 6.00]
    plt.rcParams["figure.autolayout"] = True


    xr1, yr1 = polygon1.exterior.xy
    if min_bounds and max_bounds:
        xr2, yr2 = polygon2.exterior.xy
    
    xe, ye = ellipse.exterior.xy
    plt.plot(xr1, yr1, c="green")
    if min_bounds and max_bounds:
        plt.plot(xr2, yr2, c="red")
    plt.plot(xe, ye, c="blue")
    plt.title("Elliptical Damage in Plate")
    plt.grid()
    
    
def rand_gen(bounds, cluster_size):
    '''Returns random array between bounds for given cluster size.'''
    rand_array = random(cluster_size) * (bounds[0] - bounds[1]) + bounds[1]
    
    return rand_array

def rand_data(var_bounds, cluster_size):
    '''Returns list of random data for each variable.'''
    rand_data = np.array([rand_gen(var_bounds[var], cluster_size) for var in range(len(var_bounds))])
    
    return rand_data

def read_damage():
    '''Read damage database from .csv file.'''

    df = pd.read_csv('core_damage_variables.csv')
    df_arr = df.to_numpy()
    return df_arr
    
def get_dam_var(dam_var):
    '''Creates a tuple containing strings with damage variables.'''

    var0 = f"pos_x = {dam_var[0]}"
    var1 = f"pos_y = {dam_var[1]}"
    var2 = f"theta_z = {dam_var[2]}"
    var3 = f"c = {dam_var[3]}"
    var4 = f"r = {dam_var[4]}"
    var5 = f"pos_z = {dam_var[5]}"
    var6 = f"theta_y = {dam_var[6]}"
    dam_var = (var0, var1, var2, var3, var4, var5, var6)
    return dam_var

def get_struct_prop(struct_var):
    '''Creates a tuple containing strings with structure variables.'''

    var1 = f"core_width = {struct_var[0]}"
    var2 = f"n_lam = {struct_var[1]}"
    var3 = f"plate_width = {struct_var[2]}"
    var4 = f"plate_height = {struct_var[3]}"
    struct_var = (var1, var2, var3, var4)
    return struct_var

def get_mat_prop(array):
    '''Creates a tuple containing strings with materials variables.'''

    var1 = f"E1 = {array[0]}"
    var2 = f"E2 = {array[1]}"
    var3 = f"G12 = {array[2]}"
    var4 = f"v12 = {array[3]}"
    var5 = f"rho_g = {array[4]}"
    var6 = f"E = {array[5]}"
    var7 = f"v = {array[6]}"
    var8 = f"G = {array[7]}"
    var9 = f"rho_r = {array[8]}"
    mat_var = (var1,var2,var3,var4,var5,var6,var7,var8,var9)
    return mat_var

def delete_lock():
    '''Checks if there is a .lock file and deletes it'''

    if os.path.exists('skin_output.lock'):
        os.remove('skin_output.lock') 

def clean_dir():
    '''Clean directory from trash files generated by APDL, leaves only .txt files'''

    for i in os.listdir():
        _, ext = os.path.splitext(i)
        if ext != '.txt':
            os.remove(i)

def rename_output(model_num):
    '''Renames output files by adding {it}_ in front of file name string.
        {it} is the iteration number
    '''

    for i in os.listdir():
        if i != 'APDL_Core_Damage.txt' and i != 'APDL_Core_Variables.txt' and not i[0].isnumeric():
            os.rename(i, f'{model_num}_{i}')

def write_var(dam_var, struct_prop, mat_prop):
    '''Writes APDL_Core_Variables.txt file for APDL input'''

    dam_var = get_dam_var(dam_var)
    struct_prop = get_struct_prop(struct_prop)
    mat_prop = get_mat_prop(mat_prop)

    var_file = open('APDL_Core_Variables.txt','w')
  
    for i in dam_var:
        var_file.write(i)
        var_file.write('\n')
    
    var_file.write('\n')
    for i in struct_prop:
        var_file.write(i)
        var_file.write('\n')

    var_file.write('\n')
    for i in mat_prop:
        var_file.write(i)
        var_file.write('\n')

    var_file.close()

def run_model(dam_var, struct_prop, mat_prop): 
    '''Runs APDL and other auxiliary functions.'''

    print(f'\n>>> Current iteration: {current_it}') # prints current iteration value

    cwd = os.path.abspath(os.getcwd())
    os.chdir(os.path.join(cwd,'core_damage')) 

    delete_lock()
    write_var(dam_var, struct_prop, mat_prop)

    os.system("\"C:\\Program Files\\ANSYS Inc\\ANSYS Student\\v212\\ansys\\bin\\winx64\\MAPDL.exe\" -b -j output -dir C:\\Users\\Ian\\Desktop\\Unifei\\GEMEC\\4_Programas\\clustering\\core_damage -i C:\\Users\\Ian\\Desktop\\Unifei\\GEMEC\\4_Programas\\clustering\\core_damage\\APDL_Core_Damage.txt -o C:\\Users\\Ian\\Desktop\\Unifei\\GEMEC\\4_Programas\\clustering\\core_damage\\Model_Output.out")
    
    clean_dir()
    rename_output(current_it)
    os.chdir('../')

    # Prints elapsed time
    stop_time = time.time()
    print(f'\n>>> Total elapsed time: {round((stop_time-start_time)/60 ,2)} [min]')

def run_cluster(struct_prop, mat_prop, start_it = 1):
    '''Calls run_model() function for every damage model after start_it value.'''
    
    print('>>> Starting clustering for skin damage')
    global it
    global current_it
    it = itertools.count(1)

    global start_time
    start_time = time.time()

    df = read_damage()
    for dam_var in df:
        current_it = next(it) # Calls iterator
        if current_it < start_it: # Starts in the given iteration
            print(f'>>> Skiping {current_it}th damage model')
            continue

        run_model(dam_var[1::], 
            struct_prop, 
            mat_prop
        )